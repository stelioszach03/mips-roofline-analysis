# Πολλαπλασιασμός δύο τετραγωνικών πινάκων (n=16)
# Υλοποίηση για QtMips με βασικές εντολές

.data
    # Πρώτος πίνακας εισόδου 16x16 (A)
    matrix_a:
    # Γραμμές 1-16
    .word 1:16, 2:16, 3:16, 4:16, 5:16, 6:16, 7:16, 8:16
    .word 9:16, 10:16, 11:16, 12:16, 13:16, 14:16, 15:16, 16:16

    # Δεύτερος πίνακας εισόδου 16x16 (B)
    matrix_b:
    # Γραμμές 1-16
    .word 1:16, 2:16, 3:16, 4:16, 5:16, 6:16, 7:16, 8:16
    .word 9:16, 10:16, 11:16, 12:16, 13:16, 14:16, 15:16, 16:16

    # Πίνακας αποτελέσματος 16x16 (C = A × B)
    result: .word 0:256   # 256 μηδενικά (16x16)

.text
.globl __start
__start:
    # Αρχικοποίηση μετρητών και διευθύνσεων
    addiu $8, $0, 0        # i = 0 (γραμμή A)
    addiu $9, $0, 0        # j = 0 (στήλη B)
    addiu $10, $0, 0       # k = 0 (δείκτης άθροισης)
    addiu $11, $0, 16      # όριο = 16
    lui $1, 0x1000         # Βάση διεύθυνσης δεδομένων

outer_loop:
    beq $8, $11, done      # Εάν i = όριο, τέλος
    nop                    # Καθυστέρηση διακλάδωσης

    addiu $9, $0, 0        # j = 0

middle_loop:
    beq $9, $11, next_row  # Εάν j = όριο, επόμενη γραμμή
    nop                    # Καθυστέρηση διακλάδωσης

    addiu $10, $0, 0       # k = 0
    addiu $14, $0, 0       # sum = 0 (άθροισμα για C[i][j])

inner_loop:
    beq $10, $11, store_result  # Εάν k = όριο, αποθήκευση αποτελέσματος
    nop                         # Καθυστέρηση διακλάδωσης

    # Φόρτωση A[i][k]
    sll $5, $8, 6          # i * 64 (16 words * 4 bytes)
    sll $6, $10, 2         # k * 4
    addu $7, $5, $6        # Συνολική μετατόπιση για A
    addu $12, $1, $7       # Διεύθυνση A[i][k]
    lw $15, 0($12)         # Φόρτωση A[i][k]

    # Φόρτωση B[k][j]
    sll $5, $10, 6         # k * 64
    sll $6, $9, 2          # j * 4
    addu $7, $5, $6        # Συνολική μετατόπιση για B
    addiu $12, $1, 1024    # Βάση του B (μετά το A)
    addu $12, $12, $7      # Διεύθυνση B[k][j]
    lw $16, 0($12)         # Φόρτωση B[k][j]

    # Πολλαπλασιασμός A[i][k] * B[k][j]
    addiu $17, $0, 0       # temp = 0
    addiu $18, $0, 0       # μετρητής επαναλήψεων
    addu $19, $0, $16      # αντίγραφο πολλαπλασιαστή

mult_loop:
    beq $18, $15, add_to_sum    # Εάν τέλος πολλαπλασιασμού
    nop                         # Καθυστέρηση διακλάδωσης

    # Έλεγχος υπερχείλισης στον πολλαπλασιασμό
    addu $20, $17, $19     # Δοκιμαστική πρόσθεση
    sltu $21, $20, $17     # Έλεγχος υπερχείλισης
    bne $21, $0, overflow_handler
    nop                    # Καθυστέρηση διακλάδωσης


    addu $17, $17, $19     # temp += B[k][j]
    addiu $18, $18, 1      # μετρητής++
    j mult_loop
    nop                    # Καθυστέρηση άλματος

add_to_sum:
    # Έλεγχος υπερχείλισης στην πρόσθεση στο άθροισμα
    addu $20, $14, $17     # Δοκιμαστική πρόσθεση στο άθροισμα
    sltu $21, $20, $14     # Έλεγχος υπερχείλισης
    bne $21, $0, overflow_handler
    nop                    # Καθυστέρηση διακλάδωσης

    addu $14, $14, $17     # sum += temp
    addiu $10, $10, 1      # k++
    j inner_loop
    nop                    # Καθυστέρηση άλματος

store_result:
    # Αποθήκευση C[i][j]
    sll $5, $8, 6          # i * 64
    sll $6, $9, 2          # j * 4
    addu $7, $5, $6        # Συνολική μετατόπιση για C
    addiu $12, $1, 2048    # Βάση του C (μετά το A και B)
    addu $12, $12, $7      # Διεύθυνση C[i][j]
    sw $14, 0($12)         # Αποθήκευση αποτελέσματος
    addiu $9, $9, 1        # j++
    j middle_loop
    nop                    # Καθυστέρηση άλματος

next_row:
    addiu $8, $8, 1        # i++
    j outer_loop
    nop                    # Καθυστέρηση άλματος

overflow_handler:
    j overflow_handler     # Ατέρμων βρόχος σε περίπτωση υπερχείλισης
    nop                    # Καθυστέρηση άλματος

done:
    j done                 # Ατέρμων βρόχος για κανονικό τερματισμό
    nop                    # Καθυστέρηση άλματος
