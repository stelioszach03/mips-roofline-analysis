# Πολλαπλασιασμός δύο τετραγωνικών πινάκων (n=8)
# Υλοποίηση για QtMips με βασικές εντολές

.data
    # Πρώτος πίνακας εισόδου 8x8 (A)
    matrix_a: .word 1, 2, 3, 4, 5, 6, 7, 8
             .word 9, 10, 11, 12, 13, 14, 15, 16
             .word 17, 18, 19, 20, 21, 22, 23, 24
             .word 25, 26, 27, 28, 29, 30, 31, 32
             .word 33, 34, 35, 36, 37, 38, 39, 40
             .word 41, 42, 43, 44, 45, 46, 47, 48
             .word 49, 50, 51, 52, 53, 54, 55, 56
             .word 57, 58, 59, 60, 61, 62, 63, 64

    # Δεύτερος πίνακας εισόδου 8x8 (B)
    matrix_b: .word 1, 2, 3, 4, 5, 6, 7, 8
             .word 9, 10, 11, 12, 13, 14, 15, 16
             .word 17, 18, 19, 20, 21, 22, 23, 24
             .word 25, 26, 27, 28, 29, 30, 31, 32
             .word 33, 34, 35, 36, 37, 38, 39, 40
             .word 41, 42, 43, 44, 45, 46, 47, 48
             .word 49, 50, 51, 52, 53, 54, 55, 56
             .word 57, 58, 59, 60, 61, 62, 63, 64

    # Πίνακας αποτελέσματος 8x8 (C = A × B)
    result: .word 0:64    # 64 μηδενικά (8x8)

.text
.globl __start
__start:
    # Αρχικοποίηση μετρητών και διευθύνσεων
    addiu $8, $0, 0        # i = 0 (γραμμή A)
    addiu $9, $0, 0        # j = 0 (στήλη B)
    addiu $10, $0, 0       # k = 0 (δείκτης άθροισης)
    addiu $11, $0, 8       # όριο = 8
    lui $1, 0x1000         # Βάση διεύθυνσης δεδομένων

outer_loop:
    beq $8, $11, done      # Εάν i = όριο, τέλος
    nop                    # Καθυστέρηση διακλάδωσης

    addiu $9, $0, 0        # j = 0

middle_loop:
    beq $9, $11, next_row  # Εάν j = όριο, επόμενη γραμμή
    nop                    # Καθυστέρηση διακλάδωσης

    addiu $10, $0, 0       # k = 0
    addiu $14, $0, 0       # sum = 0 (άθροισμα για C[i][j])

inner_loop:
    beq $10, $11, store_result  # Εάν k = όριο, αποθήκευση αποτελέσματος
    nop                         # Καθυστέρηση διακλάδωσης

    # Φόρτωση A[i][k]
    sll $5, $8, 5          # i * 32 (8 words * 4 bytes)
    sll $6, $10, 2         # k * 4
    addu $7, $5, $6        # Συνολική μετατόπιση για A
    addu $12, $1, $7       # Διεύθυνση A[i][k]
    lw $15, 0($12)         # Φόρτωση A[i][k]

    # Φόρτωση B[k][j]
    sll $5, $10, 5         # k * 32
    sll $6, $9, 2          # j * 4
    addu $7, $5, $6        # Συνολική μετατόπιση για B
    addiu $12, $1, 256     # Βάση του B (μετά το A)
    addu $12, $12, $7      # Διεύθυνση B[k][j]
    lw $16, 0($12)         # Φόρτωση B[k][j]

    # Πολλαπλασιασμός A[i][k] * B[k][j]
    addiu $17, $0, 0       # temp = 0
    addiu $18, $0, 0       # μετρητής επαναλήψεων
    addu $19, $0, $16      # αντίγραφο πολλαπλασιαστή

mult_loop:
    beq $18, $15, add_to_sum    # Εάν τέλος πολλαπλασιασμού
    nop                         # Καθυστέρηση διακλάδωσης

    # Έλεγχος υπερχείλισης στον πολλαπλασιασμό
    addu $20, $17, $19     # Δοκιμαστική πρόσθεση
    sltu $21, $20, $17     # Έλεγχος υπερχείλισης
    bne $21, $0, overflow_handler
    nop                    # Καθυστέρηση διακλάδωσης

    addu $17, $17, $19     # temp += B[k][j]
    addiu $18, $18, 1      # μετρητής++
    j mult_loop
    nop                    # Καθυστέρηση άλματος

add_to_sum:
    # Έλεγχος υπερχείλισης στην πρόσθεση στο άθροισμα
    addu $20, $14, $17     # Δοκιμαστική πρόσθεση στο άθροισμα
    sltu $21, $20, $14     # Έλεγχος υπερχείλισης
    bne $21, $0, overflow_handler
    nop                    # Καθυστέρηση διακλάδωσης

    addu $14, $14, $17     # sum += temp
    addiu $10, $10, 1      # k++
    j inner_loop
    nop                    # Καθυστέρηση άλματος

store_result:
    # Αποθήκευση C[i][j]
    sll $5, $8, 5          # i * 32
    sll $6, $9, 2          # j * 4
    addu $7, $5, $6        # Συνολική μετατόπιση για C
    addiu $12, $1, 512     # Βάση του C (μετά το A και B)
    addu $12, $12, $7      # Διεύθυνση C[i][j]
    sw $14, 0($12)         # Αποθήκευση αποτελέσματος
    addiu $9, $9, 1        # j++
    j middle_loop
    nop                    # Καθυστέρηση άλματος

next_row:
    addiu $8, $8, 1        # i++
    j outer_loop
    nop                    # Καθυστέρηση άλματος

overflow_handler:
    j overflow_handler     # Ατέρμων βρόχος σε περίπτωση υπερχείλισης
    nop                    # Καθυστέρηση άλματος

done:
    j done                 # Ατέρμων βρόχος για κανονικό τερματισμό
    nop                    # Καθυστέρηση άλματος
